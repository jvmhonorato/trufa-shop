1: Criar pasta POC(prova de conceito)

OBS:criar .prettierrc e passar configurações de padronização como: single quotes e tirar o ";"

2: dentro dela cria .envhomologacao, .env.producao e .env-example, OBS: somente .env.emaple irá pro repositório

3: Criar pix.auth.js

4: entrar na pasta POC dar o init instalar o: npm install dotenv, npm install axios

5: pra testar os .ENV  em pix.auth.js vc faz require do dotenv e passa o caminho em seguida dar um console.log e chama o arquivo com o node no terminal

Gerencianet

6: Em Gerencianet criar app pra gerar chave Client_ID e Secret  homologaçao e produção

7:Em Gerencianet criar dois certificados e salvar no projeto depois passar o eles nos .env respectivo

8: Em pix.auth.js preencher todos os GN_ENV de producao e homologacao de acordo com env.example

OBS:.GITIGNORE = .ENV.PRODUCAO E .ENV.HOMOLOGACAO 



TOKEN

9: em pixápi.js importar modilos axios, =https, fs, estanciar em baseURL a url básica de Gerencianet

10: criar função getToken() async usando o "FS" pra ler o certificado, e colhendo as credencais que vem do .env e passando outras rotinas seguindo a documentaçãop do Gerencianet

11: criar função run() e chamar a função getToken dentro dela. estanciar  o access_token 

12: Em run() headers substiuir : Authorization: "Basic " + auth, por Authorization: "Bearer " + access_token, e em URL: url: baseURL + "/v2/cob"

13: refatorar o run() de acordo com a requisição no modo token removendo algun  códigos que ficaram desnecessário em relação ao getToken() acima

14: OBS:https://dev.gerencianet.com.br/docs/api-pix-endpoints
Noo endpoint mostra os atributos a serme pasados em:  "data"

15:Entre getToken e run() criar a função createCharge(accessTken, chargeData) passando os paramentro token e data 

16: m seguida o modelo de data que seria o parametro chatgeData add em run() estanciado em cop, depois em run() estanciar a função createcharge(accessToken, cob) dentro de run na contante cobranca depois chamar console.log(cobranca) 

17: colocar chave pix em uma variável de ambiente: process.env.CHAVE_PIX



START QRCODE

18:Criar função getLoc(accessToken. locId) url: baseURL +'/v2/loc/'+locId + '/qrcod' com o method "GET", sem o data
e passar a chamada: const qrcode = await getLoc(accessToken, cobranca.loc.id) OBS: o loc está atrelado ao qrcode

19: passa no env.producao a CHAVE_PIX verdadeira criada no Gerencianet

//ORDEM backend
getToken()
createCharge(accessToken, chargeData)
getLoc(accessToken, locId)
run()


FRONTEND

20: Começar o front end criando nova pasta e entrando nela com cd trufa-shop-FRONTEND
21: npm init -y

22: npm install next react react-dom

23: modificar o script em package.json com: 'build'= prepara as rotas estáticas, 'dev'=inicia o projeto em modo desenvolvedor, 'start'= auxilia dinamicamente o next a trablhar , se a aplicaçõ fosse estática bastava o build

24:criar page/index.js que será o componmente principal da app

25: criar em index.js a função getServerSideProps async

PRISMIC

25: Logar no: https://prismic.io/dashboard , criar repositorio

26: instalar prismic:
1= npx @slicemachine/init --repository victortrufashop
2= npm run slicemachine
3= logar em https//:localhost:9999
4= npm install prismic-javascript

27:Repeatable type

29: estanciar em cliente: const client = Prismic.client('https://victortrufashop.prismic.io/api/v2') pegar a URL em prismic.io API & Secutity
estancia a URLcom o Prismisc.client, em seguida  passar ela na props pra retorna pro JSX e renderizar o resultado

TAILWIND NO NEXT

30: instalar Tailwind seguindo a documentção : npm install -D tailwindcss postcss autoprefixer, criar pasta style/global.css add imports, e modificar o arquivo tailwind.config de acorod com a documentação
31: criar  pages/_app.js que será o arquivo que englobará todos da aplicação. importa o tailwind nele pra que toda a app fique estilizada

32: em tailwindcomponente.com escolher o melhor card pra o projeto show the code and copy to the project 

33: editar o card de acordo com o projeto , testar como cards ficarão na tela com um array product em seguida passar: 
products.map((product) =>(<section><section/>)), abstrair o {products} = props e passar no .map os valores correpndentes de acorod com o que retorna em {JSON.stringjy(props)}

34: usar o flex-wrap pra pra descer os arrays

35: criar pasta public e por logo.png dentro dela

36: em tailwind/ resources/ heroicons buscar por cart escolher carrinho copiar JSX depois cria uma função e colar o jsx dentro em seguida no botão passar a função cmo componete React entre os <buttons> na função do heroicon usar () e não {}



controle do carrinho:
37: Pra passar o componente <Product/> dentro do .map() en Index.js em Product.js passar o (props) no componente e abstrair o const {product} = props ou simplismente passar ({product}) direto no componente e no Index.js passar :   <Products product={product}/> 

38:Componentizei separadamente todos os componetes inclusive o CartIcons.js


CONTEXT API 

39: Cria componete CartContext.js  importar o createContext e estanciar, crair uma função CartProvider

40: Ainda em CartContext.js criar na função CartContext({children}) um useState cart, setCart e add uma função addtoCart(): que será o modleo de interface a ser usado nos outros componetes com valor real  e nela da o setCart() pegando o valor antigo ...old e colocar o product.id

41: no return passar Em componente: o <CartContext value={state, função de add}> 

Exportar CartContext, CartProvider

41: IMPORTAR E USAR CartProvider em _app.js NO ESTILO WRAP ABRAÇANDO P <Component {...pageProps}/> em _app.js DESSA FORMA EXPANDIR O CONTEXTO PRA TODA APLICAÇÃO

42: Depois é só importar o CartContext no componete que desejar usar o contexto e estancair em uma constante usando o hook useContext.
OB:  SEMPRE QUE QUISER MANIFESTAR UMA AÇÕ GLOBALMENTE DE FOMRASIMUNTANIA USAR O CONTEXT API OU REDUX

TESTE/*
43: No Header.js criar um botão com evento onClick chamando a função add que tem a função addToCart que vem la do CartContext

44: Em product passar o   const cart = useContext(CartContext) e passar uma função dentro da função, emseguida no <button> passar o evento onClick chamndo add(product)  que irá chamr a função dentro da função com o product fixo
*/

45: Em header.js estanciar Object.keys(cart.cart) e retornr no botão de carrinho pra mostra a qunatidade de produtos adicionadas

46:Em Index.js passar o context e mostrar na tela pra testar com o {JSON.stringjy(cart.cart)}



PERSISTIR 
Localstorage pra aplicação

47: Em CartContext.js na função addToCart() envolver a lógica principal em uma função , passar a mesma dentro de um windows.LocalStorage em seguida retornar essa função

48:Criar um useEffect() e dentro dele estanciar cartLocal pegando o window.LocalStorage('cart') em seguida criar uma condiconal pra se caso houver algo nesse local storage dar um setCart desse valor pra cart na fomra de JSON: que nesse caso é o state que representa o valor da carteira.
 OBS: essa é a forma de passar o valor do localstorage pra a aplicação .



 REDUCE
 49: caso queria mostra a soma da qunatidade(quantity) de cada sabor de cada item em CartContext.js, usar o REDUCE pois ele tem dois parâmetros o previous e o current, no return do reduce passar o prev + cart.cart[curr].quantity. quantity é a quantidade de trufas no banco de dados

