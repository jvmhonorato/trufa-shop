1: Criar pasta POC(prova de conceito)

OBS:criar .prettierrc e passar configurações de padronização como: single quotes e tirar o ";"

2: dentro dela cria .envhomologacao, .env.producao e .env-example, OBS: somente .env.emaple irá pro repositório

3: Criar pix.auth.js

4: entrar na pasta POC dar o init instalar o: npm install dotenv, npm install axios

5: pra testar os .ENV  em pix.auth.js vc faz require do dotenv e passa o caminho em seguida dar um console.log e chama o arquivo com o node no terminal

Gerencianet

6: Em Gerencianet criar app pra gerar chave Client_ID e Secret  homologaçao e produção

7:Em Gerencianet criar dois certificados e salvar no projeto depois passar o eles nos .env respectivo

8: Em pix.auth.js preencher todos os GN_ENV de producao e homologacao de acordo com env.example

OBS:.GITIGNORE = .ENV.PRODUCAO E .ENV.HOMOLOGACAO 



TOKEN

9: em pixápi.js importar modilos axios, =https, fs, estanciar em baseURL a url básica de Gerencianet

10: criar função getToken() async usando o "FS" pra ler o certificado, e colhendo as credencais que vem do .env e passando outras rotinas seguindo a documentaçãop do Gerencianet

11: criar função run() e chamar a função getToken dentro dela. estanciar  o access_token 

12: Em run() headers substiuir : Authorization: "Basic " + auth, por Authorization: "Bearer " + access_token, e em URL: url: baseURL + "/v2/cob"

13: refatorar o run() de acordo com a requisição no modo token removendo algun  códigos que ficaram desnecessário em relação ao getToken() acima

14: OBS:https://dev.gerencianet.com.br/docs/api-pix-endpoints
Noo endpoint mostra os atributos a serme pasados em:  "data"

15:Entre getToken e run() criar a função createCharge(accessTken, chargeData) passando os paramentro token e data 

16: m seguida o modelo de data que seria o parametro chatgeData add em run() estanciado em cop, depois em run() estanciar a função createcharge(accessToken, cob) dentro de run na contante cobranca depois chamar console.log(cobranca) 

17: colocar chave pix em uma variável de ambiente: process.env.CHAVE_PIX



START QRCODE

18:Criar função getLoc(accessToken. locId) url: baseURL +'/v2/loc/'+locId + '/qrcod' com o method "GET", sem o data
e passar a chamada: const qrcode = await getLoc(accessToken, cobranca.loc.id) OBS: o loc está atrelado ao qrcode

19: passa no env.producao a CHAVE_PIX verdadeira criada no Gerencianet

//ORDEM backend
getToken()
createCharge(accessToken, chargeData)
getLoc(accessToken, locId)
run()


FRONTEND

20: Começar o front end criando nova pasta e entrando nela com cd trufa-shop-FRONTEND
21: npm init -y

22: npm install next react react-dom

23: modificar o script em package.json com: 'build'= prepara as rotas estáticas, 'dev'=inicia o projeto em modo desenvolvedor, 'start'= auxilia dinamicamente o next a trablhar , se a aplicaçõ fosse estática bastava o build

24:criar page/index.js que será o componmente principal da app

25: criar em index.js a função getServerSideProps async

PRISMIC

25: Logar no: https://prismic.io/dashboard , criar repositorio

26: instalar prismic:
1= npx @slicemachine/init --repository victortrufashop
2= npm run slicemachine
3= logar em https//:localhost:9999
4= npm install prismic-javascript

27:Repeatable type

29: estanciar em cliente: const client = Prismic.client('https://victortrufashop.prismic.io/api/v2') pegar a URL em prismic.io API & Secutity
estancia a URLcom o Prismisc.client, em seguida  passar ela na props pra retorna pro JSX e renderizar o resultado

TAILWIND NO NEXT

30: instalar Tailwind seguindo a documentção : npm install -D tailwindcss postcss autoprefixer, criar pasta style/global.css add imports, e modificar o arquivo tailwind.config de acorod com a documentação
31: criar  pages/_app.js que será o arquivo que englobará todos da aplicação. importa o tailwind nele pra que toda a app fique estilizada

32: em tailwindcomponente.com escolher o melhor card pra o projeto show the code and copy to the project 

33: editar o card de acordo com o projeto , testar como cards ficarão na tela com um array product em seguida passar: 
products.map((product) =>(<section><section/>)), abstrair o {products} = props e passar no .map os valores correpndentes de acorod com o que retorna em {JSON.stringjy(props)}

34: usar o flex-wrap pra pra descer os arrays